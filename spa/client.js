(()=>{"use strict";var __webpack_exports__={};const reISO=/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*))(?:Z|(\+|-)([\d|:]*))?$/;const reMsAjax=/^\/Date\((d|-|.*)\)[\/|\\]$/;function dateParser(key,value){if(typeof value==="string"){let a=reISO.exec(value);if(a)return new Date(value);a=reMsAjax.exec(value);if(a){const b=a[1].split(/[-+,.]/);return new Date(b[0]?+b[0]:0- +b[1])}}return value};function deserialize(string){return JSON.parse(string,dateParser)};;const state=deserialize(decodeURIComponent(document.querySelector(`[name=nullstack]`).content));const client_state=state;function fragment({children}){return children};;const seed=Object.freeze([]);function normalize(child){return child!==null&&child!==void 0?child:false}function element_element(type,props,...children){children=seed.concat(...children).map(normalize);if(type==="textarea"){children=[children.join("")]}const attributes={...props,children};if(type==="style"&&!attributes.html){attributes.html=children.join("")}if(type==="element"){type=attributes.tag||fragment;delete attributes.tag}if(typeof type==="function"&&type.render!==undefined){return{type,attributes,children:null}}return{type,attributes,children}};;function generateKey(scope,node,depth){if(node.attributes.key)return node.attributes.key;const prefix=depth.length===1?"application":node.type.name+"/"+depth;if(node.attributes.route){return prefix+(scope.context.environment.mode==="ssg"?scope.context.router.path:scope.context.router.url)}return prefix};;function isUndefined(node){if(node===undefined)return true;if(node===null)return false;return node.hasOwnProperty("type")&&node.type===undefined}function isFalse(node){if(node===null||node===false)return true;return(node===null||node===void 0?void 0:node.hasOwnProperty("type"))&&node.type===null||node.type===false}function isClass(node){return typeof node.type==="function"&&node.type.prototype&& typeof node.type.prototype.render==="function"}function isFunction(node){return typeof node.type==="function"}function isText(node){return node.type==="text"};function extractLocation(originalUrl){let[target,hash]=originalUrl.split("#");let[path,search]=target.split("?");if(path!=="/"&&path.endsWith("/")){path=path.substring(0,path.length-1)}let url=path;if(search){url+="?"+search}let urlWithHash=url;if(hash){urlWithHash+="#"+hash}if(hash===undefined){hash=""}return{path,search,url,urlWithHash,hash}};;function extractParamValue(value){if(value==="true")return true;if(value==="false")return false;return value?decodeURIComponent(value.replace(/\+/g," ")):""};;function routeMatches(url,route){let{path}=extractLocation(url);const urlPaths=path.split("/");const routePaths=route.split("/");const params={};const length=Math.max(urlPaths.length,routePaths.length);let catchall=false;for(let i=0;i<length;i++){if(catchall){continue}else if(routePaths[i]==="*"){catchall=true}else if(routePaths[i]&&routePaths[i].startsWith(":")){const key=routePaths[i].replace(":","");params[key]=extractParamValue(urlPaths[i])}else if(routePaths[i]!==urlPaths[i]){return false}}return params};;function erase(node){node.type=false;delete node.attributes;delete node.children}function match(node){return node&&node.attributes!==undefined&&node.attributes.route!==undefined}function load({router}){router._routes={}}function transform({node,depth,router}){if(!match(node))return;const routeDepth=depth.slice(0,depth.lastIndexOf("-"));if(router._routes[routeDepth]!==undefined){erase(node)}else{const params=routeMatches(router.url,node.attributes.route);if(params){router._routes[routeDepth]=true;Object.assign(router._segments,params)}else{erase(node)}}}const routable={load,transform,client:true,server:true};function noop(){};;var _attributes,_attributes1,_attributes2;function bindable_match(node){var ref;return(node===null||node===void 0?void 0:(ref=node.attributes)===null||ref===void 0?void 0:ref.bind)!==undefined}function bindable_transform({node,environment}){if(!bindable_match(node))return;var _object;const object=(_object=node.attributes.bind.object)!==null&&_object!==void 0?_object:{};const property=node.attributes.bind.property;if(node.type==="textarea"){node.children=[object[property]]}else if(node.type==="input"&&node.attributes.type==="checkbox"){node.attributes.checked=object[property]}else{var _property;node.attributes.value=(_property=object[property])!==null&&_property!==void 0?_property:""}if(environment.client){if(node.attributes.type==="checkbox"||node.attributes.type==="radio"){var _onclick;(_onclick=(_attributes=node.attributes).onclick)!==null&&_onclick!==void 0?_onclick:_attributes.onclick=noop}else if(node.type!=="input"&&node.type!=="textarea"){var _onchange;(_onchange=(_attributes1=node.attributes).onchange)!==null&&_onchange!==void 0?_onchange:_attributes1.onchange=noop}else{var _oninput;(_oninput=(_attributes2=node.attributes).oninput)!==null&&_oninput!==void 0?_oninput:_attributes2.oninput=noop}}}const bindable={transform:bindable_transform,client:true,server:true};function serializeParam(value){var ref;var ref1;return(ref1=value===null||value===void 0?void 0:(ref=value.toJSON)===null||ref===void 0?void 0:ref.call(value))!==null&&ref1!==void 0?ref1:value};;function serializeSearch(params){const keys=Object.keys(params);return keys.map(key=>{if(params[key]===false||!!params[key]){return`${key}=${params[key]}`}else{return""}}).filter(segment=>!!segment).join("&")};;function parameterizable_match(node){return node&&node.attributes&&(node.attributes.params||node.attributes.path)}function parameterizable_transform({node,router,params}){if(!parameterizable_match(node))return;let serializedParams;if(node.attributes.params){serializedParams={};for(const key in node.attributes.params){serializedParams[key]=serializeParam(node.attributes.params[key])}}else{serializedParams=params}const search=serializeSearch(serializedParams);const path=node.attributes.path||router.path;node.attributes.href=path+(search?"?":"")+search;delete node.attributes.path;delete node.attributes.params}const parameterizable={transform:parameterizable_transform,client:true,server:true};var anchorable_attributes;function anchorable_match(node){return node&&node.type==="a"&&node.attributes.href&&node.attributes.href.startsWith("/")&&!node.attributes.target}function anchorable_transform({node}){if(!anchorable_match(node))return;var _onclick;(_onclick=(anchorable_attributes=node.attributes).onclick)!==null&&_onclick!==void 0?_onclick:anchorable_attributes.onclick=noop}const anchorable={transform:anchorable_transform,client:true};const plugins=[parameterizable,anchorable,routable,bindable];function transformNodes(scope,node,depth){for(const plugin of plugins){plugin.transform({...scope.context,node,depth})}}function loadPlugins(scope){for(const plugin of plugins){plugin.load&&plugin.load(scope.context)}return plugins}function useClientPlugins(plugin){if(plugin.client)plugins.push(plugin)}function useServerPlugins(plugin){if(plugin.server)plugins.push(plugin)};var generateTree_attributes;async function generateBranch(siblings,node,depth,scope){transformNodes(scope,node,depth);if(isUndefined(node)){let message="Attempting to render an undefined node. \n";if(node===undefined){message+="This error usually happens because of a missing return statement around JSX or returning undefined from a renderable function."}else{message+="This error usually happens because of a missing import statement or a typo on a component tag"}throw new Error(message)}if(isFalse(node)){siblings.push({type:false,attributes:{}});return}if(isClass(node)){const key=generateKey(scope,node,depth);const instance=scope.instances[key]||new node.type(scope);instance.persistent=!!node.attributes.persistent;instance.key=key;instance._attributes=node.attributes;instance._scope=scope;let memory;if(scope.memory){memory=scope.memory[key];if(memory){instance.prerendered=true;instance.initiated=true;Object.assign(instance,memory);delete scope.memory[key]}}let shouldHydrate=false;const shouldLaunch=instance.initiated&&(!instance.prerendered||instance.persistent&&instance.terminated);if(instance.terminated){shouldHydrate=true;instance.terminated=false}const shouldPrepare=scope.instances[key]===undefined;scope.instances[key]=instance;if(shouldPrepare){if(memory===undefined){instance.prepare&&instance.prepare();if(scope.context.environment.server){instance.initiate&&await instance.initiate();instance.initiated=true;instance.launch&&instance.launch()}else{scope.initiationQueue.push(instance)}}shouldHydrate=true}if(scope.hydrationQueue){if(shouldHydrate){shouldLaunch&&instance.launch&&instance.launch();scope.hydrationQueue.push(instance)}else if(instance.initiated===true){instance.update&&instance.update()}}if(scope.context.environment.client){scope.renewalQueue.push(instance)}const children=instance.render();if(children&&children.type){children.instance=instance}node.children=[].concat(children);for(let i=0;i<node.children.length;i++){await generateBranch(siblings,node.children[i],depth+"-"+i,scope)}return}if(node.type==="body"){node.type=fragment;for(const attribute in node.attributes){if(attribute==="children"||attribute.startsWith("_"))continue;if(attribute==="class"||attribute==="style"){if(!scope.nextBody[attribute]){scope.nextBody[attribute]=[]}scope.nextBody[attribute].push(node.attributes[attribute])}else if(attribute.startsWith("on")){if(scope.context.environment.server)continue;if(!scope.nextBody[attribute]){scope.nextBody[attribute]=[]}if(Array.isArray(node.attributes[attribute])){scope.nextBody[attribute].push(...node.attributes[attribute])}else{scope.nextBody[attribute].push(node.attributes[attribute])}}else{scope.nextBody[attribute]=node.attributes[attribute]}}}if(isFunction(node)){const context=node.type.name?scope.generateContext(node.attributes):node.attributes;const children=node.type(context);node.children=[].concat(children);for(let i=0;i<node.children.length;i++){await generateBranch(siblings,node.children[i],depth+"-"+i,scope)}return}if(node.type){if(node.type==="head"){siblings.push({type:false,attributes:{}});for(let i=0;i<node.children.length;i++){const id=depth+"-"+i;await generateBranch(scope.nextHead,node.children[i],id,scope);var _id;(_id=(generateTree_attributes=scope.nextHead[scope.nextHead.length-1].attributes).id)!==null&&_id!==void 0?_id:generateTree_attributes.id=id}}else if(node.children){const branch={type:node.type,attributes:node.attributes,children:[]};for(let i=0;i<node.children.length;i++){await generateBranch(branch.children,node.children[i],depth+"-"+i,scope)}siblings.push(branch)}return}siblings.push({type:"text",text:node})}async function generateTree(node,scope){const tree={type:"div",attributes:{id:"application"},children:[]};await generateBranch(tree.children,node,"0",scope);return tree};;const objectProxyHandler={set(target,name,value){if(isProxyable(name,value)){target[name]=new Proxy(value,this)}else{target[name]=value}if(!name.startsWith("_")){client_client.update()}return true},get(target,name){if(name==="_isProxy")return true;return Reflect.get(...arguments)}};function isProxyable(name,value){if(name.startsWith("_"))return false;const constructor=value===null||value===void 0?void 0:value.constructor;if(!constructor)return false;if(value._isProxy)return false;return constructor===Array||constructor===Object}function generateObjectProxy(name,value){if(isProxyable(name,value)){if(typeof value==="object"){for(const key of Object.keys(value)){value[key]=generateObjectProxy(key,value[key])}}return new Proxy(value,objectProxyHandler)}else{return value}}const client_objectProxyHandler=null&&objectProxyHandler;const context1={};for(const key1 of Object.keys(client_state.context)){context1[key1]=generateObjectProxy(key1,client_state.context[key1])}const contextProxyHandler={set(target,name,value){context1[name]=generateObjectProxy(name,value);client_client.update();return true},get(target,name){if(name==="_isProxy")return true;return target[name]===undefined?context1[name]:target[name]}};function generateContext(temporary){return new Proxy(temporary,contextProxyHandler)}const client_context=context1;const environment1={...client_state.environment,client:true,server:false,event:"nullstack.environment"};const client_environment=environment1;let timer=null;function windowEvent(name){clearTimeout(timer);setTimeout(()=>{const event=new Event("nullstack."+name);window.dispatchEvent(event)},0)};;const page1={...client_state.page,event:"nullstack.page"};delete client_state.page;const pageProxyHandler={set(target,name,value){if(name==="title"){document.title=value}const result=Reflect.set(...arguments);if(name==="title"){windowEvent("page")}client_client.update();return result}};const proxy1=new Proxy(page1,pageProxyHandler);const client_page=proxy1;function getQueryStringParams(url){const[path,query]=url.split("?");if(query){return query.split("&").reduce((params,param)=>{let[key,value]=param.split("=");params[key]=extractParamValue(value);return params},{})}else{return{}}};;;const segments={};const client_segments=segments;function resetSegments(){for(const key in segments){delete segments[key]}};const paramsProxyHandler={set(target,name,value){const serializedValue=serializeParam(value);target[name]=serializedValue;const search=serializeSearch(target);client_router.url=client_router.path+(search?"?":"")+search;return true},get(target,name){if(target[name]===false)return false;if(client_segments[name]===false)return false;return target[name]||client_segments[name]||""}};const params1={...client_state.params};delete client_state.params;const params_proxy=new Proxy(params1,paramsProxyHandler);function updateParams(query){resetSegments();const delta=getQueryStringParams(query);for(const key of Object.keys({...delta,...params1})){params1[key]=delta[key]}return params_proxy}const client_params=params_proxy;const worker={...client_state.worker};delete client_state.worker;const emptyQueue=Object.freeze([]);const queuesProxyHandler={set(target,name,value){target[name]=value;client_client.update();return true},get(target,name){return target[name]||emptyQueue}};worker.queues=new Proxy({},queuesProxyHandler);const workerProxyHandler={set(target,name,value){if(target[name]!==value){target[name]=value;client_client.update()}return true}};const worker_proxy=new Proxy(worker,workerProxyHandler);if(worker.enabled){window.addEventListener("beforeinstallprompt",function(event){event.preventDefault();worker_proxy.installation=event});async function register(){if("serviceWorker"in navigator){const request=`/service-worker.js`;try{worker_proxy.registration=await navigator.serviceWorker.register(request,{scope:"/"})}catch(error){console.log(error)};}};register()}window.addEventListener("online",()=>{worker_proxy.online=true;if(client_environment.mode==="ssg"){client_router._update(client_router.url)}else{worker_proxy.responsive=true}});window.addEventListener("offline",()=>{worker_proxy.online=false});const client_worker=worker_proxy;function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true})}else{obj[key]=value}return obj}let redirectTimer=null;class Router{async _popState(){const{urlWithHash}=extractLocation(window.location.pathname+window.location.search);await this._update(urlWithHash,false)}async _update(target,push){const{url,path,hash,urlWithHash}=extractLocation(target);if(url===this._url&&this._hash===hash)return;this.previous=this.url;clearTimeout(redirectTimer);redirectTimer=setTimeout(async()=>{client_page.status=200;if(client_environment.mode==="ssg"){client_worker.fetching=true;const api="/index.json";const endpoint=path==="/"?api:path+api;try{const response=await fetch(endpoint);const payload=await response.json(url);client_client.memory=payload.instances;for(const key in payload.page){client_page[key]=payload.page[key]}client_worker.responsive=true}catch(error){client_worker.responsive=false}client_worker.fetching=false}if(push){history.pushState({},document.title,urlWithHash)}this._url=url;this._hash=hash;this._changed=true;updateParams(url);client_client.update();windowEvent("router")},0)}async _redirect(target){if(/^(\w+:|\/\/)([^.]+.)/.test(target)){return window.location.href=target}const absoluteUrl=new URL(target,document.baseURI);await this._update(absoluteUrl.pathname+absoluteUrl.search+absoluteUrl.hash,true);window.scroll(0,0)}get url(){return this._url}set url(target){this._redirect(target)}get path(){return extractLocation(this._url).path}set path(target){this._redirect(target+window.location.search)}get base(){if(this._base)return this._base;this._base=new URL(document.querySelector('[rel="canonical"]').href).origin;return this._base}constructor(){_defineProperty(this,"event","nullstack.router");_defineProperty(this,"previous",null);_defineProperty(this,"_changed",false);_defineProperty(this,"_segments",client_segments);const{hash,url}=extractLocation(window.location.pathname+window.location.search);this._url=url;this._hash=hash}}const router1=new Router;const client_router=router1;function anchorableElement(element){const links=element.querySelectorAll('a[href^="/"]:not([target])');for(const link of links){link.addEventListener("click",event=>{if(!event.ctrlKey&&!event.shiftKey&&!event.altKey&&!event.metaKey){event.preventDefault();client_router.url=link.getAttribute("href")}})}};function camelize(key){return key.toLowerCase().replace(/[^a-zA-Z0-9]+(.)/g,(m,chr)=>chr.toUpperCase())}function kebabize(key){return key.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g,"$1-$2").toLowerCase()};;const eventCallbacks=new WeakMap;const eventSubjects=new WeakMap;const eventDebouncer=new WeakMap;function executeEvent(callback,subject,event,data){if(typeof callback==="object"){Object.assign(subject.source,callback)}else{callback({...subject,event,data})}}function debounce(selector,name,time,callback){if(!time){callback()}else{const eventMap=eventDebouncer.get(selector)||{};clearTimeout(eventMap[name]);eventMap[name]=setTimeout(callback,time);eventDebouncer.set(selector,eventMap)}}function generateCallback(selector,name){return function eventCallback(event){const subject=eventSubjects.get(selector);if(!subject)return;if(subject.href){if(!event.ctrlKey&&!event.shiftKey&&!event.altKey&&!event.metaKey){event.preventDefault();client_router.url=subject.href}}else if(subject.default!==true){event.preventDefault()}debounce(selector,name,subject.debounce,()=>{const data={...subject.data};for(const attribute in subject){if(attribute.startsWith("data-")){const key=camelize(attribute.slice(5));data[key]=subject[attribute]}}if((subject===null||subject===void 0?void 0:subject.bind)!==undefined){const valueName=subject.type==="checkbox"||subject.type==="radio"?"checked":"value";const object=subject.bind.object;const property=subject.bind.property;if(valueName==="checked"){object[property]=event.target[valueName]}else if(object[property]===true||object[property]===false){object[property]=event.target[valueName]==="true"}else if(typeof object[property]==="number"){object[property]=+event.target[valueName]||0}else{object[property]=event.target[valueName]}}if(subject[name]===noop)return;if(Array.isArray(subject[name])){for(const subcallback of subject[name]){executeEvent(subcallback,subject,event,data)}}else{executeEvent(subject[name],subject,event,data)}})}};;const refMap=new WeakMap;function setup(attributes,element){const object=attributes.ref.object;const property=attributes.ref.property;if(typeof object[property]==="function"){setTimeout(()=>{object[property]({...attributes,element})},0)}else{object[property]=element}const map=refMap.get(attributes.ref.object)||{};map[attributes.ref.property]=true;refMap.set(attributes.ref.object,map)}function ref1(attributes,element){if(!(attributes===null||attributes===void 0?void 0:attributes.ref))return;setup(attributes,element)}function reref(attributes,element){const map=refMap.get(attributes.ref.object);if(map===null||map===void 0?void 0:map[attributes.ref.property])return;setup(attributes,element)};const generateTruthyString_seed=Object.freeze([]);function generateTruthyString(elements){return generateTruthyString_seed.concat(...elements).filter(Boolean).join(" ")};;function render(node,options){if(isFalse(node)||node.type==="head"){node.element=document.createComment("");return node.element}if(isText(node)){node.element=document.createTextNode(node.text);return node.element}const svg=options&&options.svg||node.type==="svg";if(svg){node.element=document.createElementNS("http://www.w3.org/2000/svg",node.type)}else{node.element=document.createElement(node.type)}ref1(node.attributes,node.element);for(let name in node.attributes){if(name==="debounce")continue;if(name==="html"){node.element.innerHTML=node.attributes[name];node.head||anchorableElement(node.element)}else if(name.startsWith("on")){if(node.attributes[name]!==undefined){const eventName=name.substring(2);const callback=generateCallback(node.element,name);node.element.addEventListener(eventName,callback);eventCallbacks.set(node.element,callback);eventSubjects.set(node.element,node.attributes)}}else{let nodeValue;if((name==="class"||name==="style")&&Array.isArray(node.attributes[name])){nodeValue=generateTruthyString(node.attributes[name])}else{nodeValue=node.attributes[name]}const type=typeof nodeValue;if(type!=="object"&&type!=="function"){if(name!="value"&&nodeValue===true){node.element.setAttribute(name,"")}else if(name==="value"||nodeValue!==false&&nodeValue!==null&&nodeValue!==undefined){node.element.setAttribute(name,nodeValue)}}}}if(!node.attributes.html){for(let i=0;i<node.children.length;i++){const child=render(node.children[i],{svg});node.element.appendChild(child)}if(node.type==="select"){node.element.value=node.attributes.value}}return node.element};;function updateAttributes(selector,currentAttributes,nextAttributes){const attributeNames=Object.keys({...currentAttributes,...nextAttributes});for(const name of attributeNames){var ref;if(name==="debounce")continue;if(name==="ref"&&(nextAttributes===null||nextAttributes===void 0?void 0:(ref=nextAttributes.ref)===null||ref===void 0?void 0:ref.property)){reref(nextAttributes,selector)}else if(name==="html"){if(nextAttributes[name]!==currentAttributes[name]){selector.innerHTML=nextAttributes[name];anchorableElement(selector)}}else if(name==="checked"||name==="value"){if(nextAttributes[name]!==currentAttributes[name]&&nextAttributes[name]!==selector[name]){selector[name]=nextAttributes[name]}}else if(name.startsWith("on")){const eventName=name.substring(2);if(eventCallbacks.has(selector)&&!nextAttributes[name]){selector.removeEventListener(eventName,eventCallbacks.get(selector))}if(nextAttributes[name]){if(!eventCallbacks.has(selector)){const callback=generateCallback(selector,name);selector.addEventListener(eventName,callback);eventCallbacks.set(selector,callback)}eventSubjects.set(selector,nextAttributes)}}else{let currentValue;if((name==="class"||name==="style")&&Array.isArray(currentAttributes[name])){currentValue=generateTruthyString(currentAttributes[name])}else{currentValue=currentAttributes[name]}let nextValue;if((name==="class"||name==="style")&&Array.isArray(nextAttributes[name])){nextValue=generateTruthyString(nextAttributes[name])}else{nextValue=nextAttributes[name]}const type=typeof nextValue;if(type!=="object"&&type!=="function"){if(currentValue!==undefined&&nextValue===undefined){selector.removeAttribute(name)}else if(currentValue!==nextValue){if(name!="value"&&nextValue===false||nextValue===null||nextValue===undefined){selector.removeAttribute(name)}else if(name!="value"&&nextValue===true){selector.setAttribute(name,"")}else{selector.setAttribute(name,nextValue)}}}}}}function updateHeadChild(current,next){if(isUndefined(current)&&!isUndefined(next)){const nextSelector=render(next);client_client.head.append(nextSelector);return}if(!isUndefined(current)&&isUndefined(next)){current.element.remove();return}next.element=current.element;if(isFalse(current)&&isFalse(next)){return}if(current.type!==next.type){const nextSelector=render(next);current.element.replaceWith(nextSelector);return}updateAttributes(current.element,current.attributes,next.attributes)}function updateHeadChildren(currentChildren,nextChildren){const limit=Math.max(currentChildren.length,nextChildren.length);for(let i=0;i<limit;i++){updateHeadChild(currentChildren[i],nextChildren[i])}}function _rerender(current,next){const selector=current.element;next.element=current.element;if(isFalse(current)&&isFalse(next)){return}if(current.type!==next.type){const nextSelector=render(next);selector.replaceWith(nextSelector);return}if(isText(current)&&isText(next)){if(current.text!==next.text){selector.textContent=next.text}return}if(!next.attributes.html){const limit=Math.max(current.children.length,next.children.length);if(next.children.length>current.children.length){for(let i=0;i<current.children.length;i++){_rerender(current.children[i],next.children[i])}for(let i1=current.children.length;i1<next.children.length;i1++){const nextSelector=render(next.children[i1]);selector.appendChild(nextSelector)}}else if(current.children.length>next.children.length){for(let i=0;i<next.children.length;i++){_rerender(current.children[i],next.children[i])}for(let i2=current.children.length-1;i2>=next.children.length;i2--){selector.childNodes[i2].remove()}}else{for(let i=limit-1;i> -1;i--){_rerender(current.children[i],next.children[i])}}}updateAttributes(selector,current.attributes,next.attributes)}function rerender(){_rerender(client_client.virtualDom,client_client.nextVirtualDom);updateAttributes(client_client.body,client_client.currentBody,client_client.nextBody);updateHeadChildren(client_client.currentHead,client_client.nextHead);client_client.virtualDom=client_client.nextVirtualDom;client_client.nextVirtualDom=null;client_client.currentBody=client_client.nextBody;client_client.nextBody={};client_client.currentHead=client_client.nextHead;client_client.nextHead=[]};;const client={};client.initialized=false;client.initializer=null;client.instances={};client_context.instances=client.instances;client.initiationQueue=[];client.renewalQueue=[];client.hydrationQueue=[];client.realHydrationQueue=[];client.virtualDom={};client.selector=null;client.events={};client.generateContext=generateContext;client.renderQueue=null;client.currentBody={};client.nextBody={};client.currentHead=[];client.nextHead=[];client.head=document.head;client.body=document.body;client.update=async function update(){if(client.initialized){clearInterval(client.renderQueue);client.renderQueue=setTimeout(async()=>{const scope=client;scope.context=client_context;scope.plugins=loadPlugins(scope);client.initialized=false;client.renewalQueue=[];try{client.nextVirtualDom=await generateTree(client.initializer(),scope);rerender();client.processLifecycleQueues()}catch(e){client.skipHotReplacement=true;console.error(e)}},16)}};client.processLifecycleQueues=async function processLifecycleQueues(){if(!client.initialized){client.initialized=true}let shouldUpdate=false;let shouldScroll=client_router._hash;while(client.initiationQueue.length){const instance=client.initiationQueue.shift();instance.initiate&&await instance.initiate();instance.initiated=true;instance.launch&&instance.launch();shouldUpdate=true;if(instance._attributes.route&&shouldScroll){const element=document.getElementById(client_router._hash);if(element){element.scrollIntoView({behavior:"smooth"})}shouldScroll=false}}shouldUpdate&&client.update();shouldUpdate=false;while(client.realHydrationQueue.length){shouldUpdate=true;const instance=client.realHydrationQueue.shift();instance.hydrate&&await instance.hydrate();instance.hydrated=true}shouldUpdate&&client.update();shouldUpdate=false;while(client.hydrationQueue.length){shouldUpdate=true;const instance=client.hydrationQueue.shift();client.realHydrationQueue.push(instance)}shouldUpdate&&client.update();for(const key in client.instances){const instance=client.instances[key];if(!client.renewalQueue.includes(instance)&&!instance.terminated){instance.terminate&&await instance.terminate();if(instance.persistent){instance.terminated=true}else{delete client.instances[key]}}}client_router._changed=false};const client_client=client;const instanceProxies=new WeakMap;const instanceProxyHandler={get(target,name){var ref;if(name==="_isProxy")return true;if(((ref=target.constructor[name])===null||ref===void 0?void 0:ref.name)==="_invoke")return target.constructor[name].bind(target.constructor);if(typeof target[name]==="function"&&name!=="constructor"){const proxy=instanceProxies.get(target);if(name.startsWith("_")){return target[name].bind(proxy)}const{[name]:named}={[name]:args=>{const context=generateContext({...target._attributes,...args});return target[name].call(proxy,context)}};return named}return Reflect.get(...arguments)},set(target,name,value){if(!name.startsWith("_")){target[name]=generateObjectProxy(name,value);client_client.update()}else{target[name]=value}return true}};const client_instanceProxyHandler=instanceProxyHandler;const prefix1="nullstack";const shared_prefix=prefix1;function invoke(name,hash){return async function _invoke(params={}){var ref;let payload;client_worker.fetching=true;if(Object.isFrozen(client_worker.queues[name])){client_worker.queues[name]=[params]}else{client_worker.queues[name]=[...client_worker.queues[name],params]}const finalHash=hash===this.hash?hash:`${hash}-${this.hash}`;let url=`${client_worker.api}/${shared_prefix}/${finalHash}/${name}.json`;let body=JSON.stringify(params||{});const options={headers:client_worker.headers,mode:"cors",cache:"no-cache",credentials:"same-origin",redirect:"follow",referrerPolicy:"no-referrer"};if(/get[A-Z]([*]*)/.test(name)){options.method="GET";url+=`?payload=${encodeURIComponent(body)}`}else{options.body=body;if(/patch[A-Z]([*]*)/.test(name)){options.method="PATCH"}else if(/put[A-Z]([*]*)/.test(name)){options.method="PUT"}else if(/delete[A-Z]([*]*)/.test(name)){options.method="DELETE"}else{options.method="POST"}}try{const response=await fetch(url,options);client_page.status=response.status;const text=await response.text();payload=deserialize(text).result;client_worker.responsive=true}catch(e){client_worker.responsive=false}if(((ref=client_worker.queues[name])===null||ref===void 0?void 0:ref.length)===1){delete client_worker.queues[name]}else{client_worker.queues[name]=client_worker.queues[name].filter(task=>task!==params)}client_worker.fetching=!!Object.keys(client_worker.queues).length;return payload}};;const project={...client_state.project};delete client_state.project;Object.freeze(project);const client_project=project;let pool=[];function hydrateBody(selector,node){var ref2;if(node===null||node===void 0?void 0:(ref2=node.attributes)===null||ref2===void 0?void 0:ref2.html){anchorableElement(selector)}node.element=selector;ref1(node.attributes,selector);for(const element of selector.childNodes){if((element.tagName==="TEXTAREA"||element.tagName==="textarea")&&element.childNodes.length===0){element.appendChild(document.createTextNode(""))}else if(element.COMMENT_NODE===8&&element.textContent==="#"){pool.push(element.remove())}}if(!node.children)return;const limit=node.children.length;for(let i=limit-1;i> -1;i--){var ref11;if(node.type!=="head"&& typeof(selector===null||selector===void 0?void 0:(ref11=selector.childNodes)===null||ref11===void 0?void 0:ref11[i])==="undefined"){console.error(`${node.type.toUpperCase()} expected tag ${node.children[i].type.toUpperCase()} to be child at index ${i} but instead found undefined. This error usually happens because of an invalid HTML hierarchy or changes in comparisons after serialization.`,selector);throw new Error("Virtual DOM does not match the DOM.")}hydrateBody(selector.childNodes[i],node.children[i])}}function hydrateHead(){for(const node of client_client.nextHead){if(isFalse(node)){node.element=pool.pop()||document.createComment("");client_client.head.append(node.element)}else{node.element=document.getElementById(node.attributes.id)}}pool=null}function hydrate(selector,node){hydrateBody(selector,node);hydrateHead()};;const settings={...client_state.settings};delete client_state.settings;Object.freeze(settings);const client_settings=settings;function client_defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true})}else{obj[key]=value}return obj}var _Nullstack;client_context.page=client_page;client_context.router=client_router;client_context.settings=client_settings;client_context.worker=client_worker;client_context.params=client_params;client_context.project=client_project;client_context.environment=client_state.environment;client_client.memory=client_state.instances;const scope1=client_client;scope1.generateContext=generateContext;scope1.context=client_context;client_client.plugins=loadPlugins(scope1);class Nullstack{static start(Starter){setTimeout(async()=>{window.addEventListener("popstate",()=>{client_router._popState()});if(client_client.initializer){client_client.initializer=()=>element_element(Starter);client_client.update();return this.context}client_client.routes={};updateParams(client_router.url);client_client.currentInstance=null;client_client.initializer=()=>element_element(Starter);client_client.selector=document.getElementById("application");if(client_environment.mode==="spa"){scope1.plugins=loadPlugins(scope1);client_worker.online=navigator.onLine;typeof client_context.start==="function"&&await client_context.start(client_context);client_context.environment=client_environment;client_client.virtualDom=await generateTree(client_client.initializer(),scope1);const body=render(client_client.virtualDom);client_client.selector.replaceWith(body);client_client.selector=body}else{client_client.virtualDom=await generateTree(client_client.initializer(),scope1);hydrate(client_client.selector,client_client.virtualDom);client_client.currentBody=client_client.nextBody;client_client.currentHead=client_client.nextHead;client_client.nextBody={};client_client.nextHead=[];client_context.environment=client_environment;scope1.plugins=loadPlugins(scope1);client_worker.online=navigator.onLine;typeof client_context.start==="function"&&await client_context.start(client_context);client_client.nextVirtualDom=await generateTree(client_client.initializer(),scope1);rerender()}client_client.processLifecycleQueues();delete client_state.context},0);return this.context}render(){return false}constructor(){client_defineProperty(this,"prerendered",false);client_defineProperty(this,"initiated",false);client_defineProperty(this,"hydrated",false);client_defineProperty(this,"terminated",false);client_defineProperty(this,"key",null);const proxy=new Proxy(this,client_instanceProxyHandler);instanceProxies.set(this,proxy);return proxy}}client_defineProperty(Nullstack,"element",element_element);client_defineProperty(Nullstack,"invoke",invoke);client_defineProperty(Nullstack,"fragment",fragment);client_defineProperty(Nullstack,"use",useClientPlugins);client_defineProperty(Nullstack,"context",generateContext({}));if(false){var _serverHashes};const nullstack=Nullstack;const request1=({method="GET",body})=>{const options={method,headers:{"Content-Type":"application/json","Access-Control-Allow-Origin":"*"},body};return fetch("https://admin.hq-now.com/graphql",options)};const getHqsService=async query=>{const body=`{"operationName":"getHqsByName","variables":{"name":"${query}"},"query":"query getHqsByName($name: String!) {
  getHqsByName(name: $name) {
    id
    name
    editoraId
    status
    publisherName
    impressionsCount
  }
}
"}`;const data=await request1({method:"POST",body});console.log(data);return[]};function Home_defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true})}else{obj[key]=value}return obj}class Home extends nullstack{prepare({page}){page.title="Hq Searcher";page.description="Find HQ and export as PDF"}onSearch(event){const query="teste";getHqsService(query)}render(){return nullstack.element("section",{class:"w-full max-w-3xl min-h-screen my-0 mx-auto flex p-6 flex-wrap md:flex-nowrap"},nullstack.element("article",{class:"w-full mb-5"},nullstack.element("form",null,nullstack.element("label",{for:"query"},"Buscar por nome ou link"),nullstack.element("input",{type:"text",id:"query",name:"query",source:this,onchange:this.onSearch}))))}}Home_defineProperty(Home,"hash","b6540d9644fe020bf949b723e17cbaf5");const src_Home=Home;if(false){};function Application_defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true})}else{obj[key]=value}return obj}class Application extends nullstack{prepare({page}){page.locale="en-US"}renderHead(){return nullstack.element("head",null,nullstack.element("link",{href:"https://fonts.gstatic.com",rel:"preconnect"}),nullstack.element("link",{href:"https://fonts.googleapis.com/css2?family=Crete+Round&family=Roboto&display=swap",rel:"stylesheet"}))}render(){const Head=this.renderHead;return nullstack.element("body",{class:"bg-gray-30 text-black font-roboto"},nullstack.element(Head,null),nullstack.element(src_Home,{route:"/",greeting:"Welcome to Nullstack!"}))}}Application_defineProperty(Application,"hash","c6fa323af87076d868fe19b6d38ef52d");const src_Application=Application;if(false){};const client_context_0=nullstack.start(src_Application);client_context_0.start=async function start(){};const client_0=null&&client_context_0;if(false){}})()